#!/usr/bin/env python

import argparse
from itertools import islice
import pandas as pd
from pandas.core.frame import DataFrame
import gzip
from scipy.stats import pearsonr
from Bio import SeqIO
from Bio.Seq import reverse_complement
import sys

def parse_arguments(parser):
    """
    Parse parameters from the command line
    """
    parser.add_argument('--pred_file', type=str, default='',
                        help='base-wise mutation rate prediction file generated by MuRaL.')
    parser.add_argument('--ref_genome', type=str, default='',
                        help='file path for the reference genome in FASTA format.')
    parser.add_argument('--out_prefix', type=str, default='result',
                        help='name prefix for output files storing regional mutation rates and correlations')
    parser.add_argument('--kmer_length', type=int, default=3,
                        help='k-mer length. Please provide a positive odd integer. Default: 3.')
    args = parser.parse_args()
    return args

def kmer_add(kmer,dict):
    '''Count the number of occurrences of all k-mers'''
    if kmer not in dict:
        dict[kmer] = 1
    else:
        dict[kmer] += 1
    return dict
        
def prob_add(kmer,prob1,prob2,prob3,prob1_sum,prob2_sum,prob3_sum):
    '''Calculate the sum of predicted mutation rates for each mutation subtype'''
    if kmer not in prob1_sum.keys():
        prob1_sum[kmer] = prob1
        prob2_sum[kmer] = prob2
        prob3_sum[kmer] = prob3
    else:
        prob1_sum[kmer] += prob1
        prob2_sum[kmer] += prob2
        prob3_sum[kmer] += prob3

def count_mut(kmer,mut,mut1_sum,mut2_sum,mut3_sum):
    '''Count the number of mutations in each mutation subtype'''
    types = {
            1:mut1_sum,
            2:mut2_sum,
            3:mut3_sum
    }
    if mut in types:
        kmer_add(kmer,types[mut])
        
def kmer_calculate(site,seq,mut_type,prob1,prob2,prob3,all_kmers,prob1_sum,prob2_sum,prob3_sum,mut1_sum,mut2_sum,mut3_sum):
    '''Process one site'''
    cal = []
    # Only the ATCG bases are allowed in k-mer
    for base in seq:
        if base in ['A','C','G','T']:
            cal.append('PASS')
        else:
            cal.append('TERMINATE')
    if 'TERMINATE' not in cal:
        if site == 'A' or site == 'C':
            kmer_add(seq,all_kmers)
            prob_add(seq,prob1,prob2,prob3,prob1_sum,prob2_sum,prob3_sum)
            count_mut(seq,mut_type,mut1_sum,mut2_sum,mut3_sum)
        elif site == 'T' or site == 'G':
            seq = reverse_complement(seq)
            kmer_add(seq,all_kmers)
            prob_add(seq,prob1,prob2,prob3,prob1_sum,prob2_sum,prob3_sum)
            count_mut(seq,mut_type,mut1_sum,mut2_sum,mut3_sum)

def main():
    parser = argparse.ArgumentParser(description='k-mer correlation calculator')
    args = parse_arguments(parser)
    ref_genome= args.ref_genome
    kmer_length = int(args.kmer_length)
    if kmer_length%2 != 1 or kmer_length <= 1:
        print('ERROR: --kmer_length only accepts a positive odd integer!', file=sys.stderr)
        sys.exit(1)
    
    outfile = open(args.out_prefix+'.'+str(kmer_length)+ '-mer.mut_rates.tsv', 'w')
    
    outfile.write('type\tavg_obs_rate1\tavg_obs_rate2\tavg_obs_rate3\tavg_pred_prob1\tavg_pred_prob2\tavg_pred_prob3\tnumber_of_mut1\tnumber_of_mut2\tnumber_of_mut3\tnumber_of_all\n')

    # Flank sequence length
    m = int(kmer_length)//2

    all_kmers = {}
    mut1_sum = {}
    mut2_sum = {}
    mut3_sum = {}
    obs_rate1 = {}
    obs_rate2 = {}
    obs_rate3 = {}
    pred_prob1_sum = {}
    pred_prob2_sum = {}
    pred_prob3_sum = {}
    avg_pred_prob1 = {}
    avg_pred_prob2 = {}
    avg_pred_prob3 = {}
    chrNo = ''

    if args.pred_file.endswith('.gz'):
        site_file = gzip.open(args.pred_file)
    else:
        site_file = open(args.pred_file)

    # Traverse the prediction file to count the occurrences of kmers, the count of mutations, and the sum of the predicted mutation rates for each kmer mutation subtypes
    for line in islice(site_file, 1, None):
        if args.pred_file.endswith('.gz'):
            info = line.decode().split('\t')
        else:
            info = line.split('\t')
            
        # Process reference sequence
        chromosome = info[0]
        if chrNo != chromosome:
            for seq_record in SeqIO.parse(ref_genome, "fasta"):
                seq_id = seq_record.id
                if seq_id == chromosome:
                    chromosomeSeq = str(seq_record.seq)
                    chromosomeSeq = chromosomeSeq.upper()
                else:
                    continue
        chrNo = chromosome
        
        # calculate the sum
        start = int(info[1]) ### check 
        base = chromosomeSeq[start]
        mut_type = int(info[4])
        prob1 = float(info[6])
        prob2 = float(info[7])
        prob3 = float(info[8])
        seq = chromosomeSeq[start-m:start+m+1]
        kmer_calculate(base,seq,mut_type,prob1,prob2,prob3,all_kmers,pred_prob1_sum,pred_prob2_sum,pred_prob3_sum,mut1_sum,mut2_sum,mut3_sum)

    # Assign 0 to k-mer without mutation
    for a in all_kmers.keys():
        if a not in mut1_sum.keys():
            mut1_sum[a] = 0
        if a not in mut2_sum.keys():
            mut2_sum[a] = 0
        if a not in mut3_sum.keys():
            mut3_sum[a] = 0

    # calculate the observed mutation rate and the average predicted mutation rate
    result_prob1 = pd.DataFrame(columns=('obs', 'pred'))
    result_prob2 = pd.DataFrame(columns=('obs', 'pred'))
    result_prob3 = pd.DataFrame(columns=('obs', 'pred'))
    for mer in all_kmers.keys():
        if all_kmers[mer] != 0:
            obs_rate1[mer] = float(mut1_sum[mer]/all_kmers[mer])
            avg_pred_prob1[mer] = float(pred_prob1_sum[mer]/all_kmers[mer])
            obs_rate2[mer] = float(mut2_sum[mer]/all_kmers[mer])
            avg_pred_prob2[mer] = float(pred_prob2_sum[mer]/all_kmers[mer])
            obs_rate3[mer] = float(mut3_sum[mer]/all_kmers[mer])
            avg_pred_prob3[mer] = float(pred_prob3_sum[mer]/all_kmers[mer])
        else:
            obs_rate1[mer] = float(0)
            avg_pred_prob1[mer] = float(0)
            obs_rate2[mer] = float(0)
            avg_pred_prob2[mer] = float(0)
            obs_rate3[mer] = float(0)
            avg_pred_prob3[mer] = float(0)

        outfile.write(str(mer)+'\t'+
                      str(obs_rate1[mer])+'\t'+
                      str(obs_rate2[mer])+'\t'+
                      str(obs_rate3[mer])+'\t'+
                      str(avg_pred_prob1[mer])+'\t'+
                      str(avg_pred_prob2[mer])+'\t'+
                      str(avg_pred_prob3[mer])+'\t'+
                      str(mut1_sum[mer])+'\t'+
                      str(mut2_sum[mer])+'\t'+
                      str(mut3_sum[mer])+'\t'+
                      str(all_kmers[mer])+'\n')

        result_prob1 = pd.concat([result_prob1,pd.DataFrame({'obs':[float(obs_rate1[mer])], 'pred':[float(avg_pred_prob1[mer])]})],axis=0)
        result_prob2 = pd.concat([result_prob2,pd.DataFrame({'obs':[float(obs_rate2[mer])], 'pred':[float(avg_pred_prob2[mer])]})],axis=0)
        result_prob3 = pd.concat([result_prob3,pd.DataFrame({'obs':[float(obs_rate3[mer])], 'pred':[float(avg_pred_prob3[mer])]})],axis=0)

    # calculate the correlation
    corr_prob1 = pearsonr(result_prob1['obs'],result_prob1['pred'])
    corr_prob2 = pearsonr(result_prob2['obs'],result_prob2['pred'])
    corr_prob3 = pearsonr(result_prob3['obs'],result_prob3['pred'])
    
    corr_file = open(args.out_prefix+'.'+str(kmer_length)+'-mer.corr.txt', 'w')

    corr_file.write(str(kmer_length)+'-mer'+'\t'+str('prob1')+'\t'+str(corr_prob1[0])+'\t'+str(corr_prob1[1])+'\n'+
                      str(kmer_length)+'-mer'+'\t'+str('prob2')+'\t'+str(corr_prob2[0])+'\t'+str(corr_prob2[1])+'\n'+
                      str(kmer_length)+'-mer'+'\t'+str('prob3')+'\t'+str(corr_prob3[0])+'\t'+str(corr_prob3[1])+'\n')
    corr_file.close()
    
if __name__ == '__main__':
    main()
